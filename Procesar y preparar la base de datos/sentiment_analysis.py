# -*- coding: utf-8 -*-
"""sentiment analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ai6ISqBhDjOk25CQDip4GSvgJarPW3Mi
"""

#Instalar las librerías necesarias si no las tienes instaladas
!pip install nltk
!pip install google-cloud-translate google-cloud-language
!pip install plotly

# Importar todas las librerías necesarias
import nltk
nltk.download('vader_lexicon')

# Librerías para análisis de sentimientos y autenticación en Google Cloud
from nltk.sentiment import SentimentIntensityAnalyzer
from google.colab import auth
from google.cloud import bigquery

# Librerías para manejo de datos
import pandas as pd
import numpy as np

# Librerías para visualización
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.figure_factory as ff
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Librerías adicionales para manejo de archivos
from google.colab import files

# Autenticación en Google Cloud
auth.authenticate_user()

# Configuración de BigQuery (puedes añadir tu project_id aquí)
project_id = 'datalab-433117'
client = bigquery.Client(project=project_id)

from google.colab import auth
from google.cloud import bigquery

# Autenticación en Google Cloud
auth.authenticate_user()

# Configuración del proyecto de Google Cloud
project_id = 'datalab-433117'
client = bigquery.Client(project=project_id)

# Consulta en BigQuery para obtener los datos de la tabla 'new_amazon_review'
query = """
SELECT *
FROM `datalab-433117.dataset.new_amazon_reviews`
"""

# Ejecuta la consulta y convierte los resultados en un DataFrame
query_job = client.query(query)
df = query_job.to_dataframe()

# Muestra las primeras filas del DataFrame
df.head()

# Inicializar el analizador de sentimientos
sia = SentimentIntensityAnalyzer()

# Lista de palabras clave positivas y negativas
positive_keywords = ['good', 'great', 'excellent', 'amazing', 'fantastic']
negative_keywords = ['bad', 'poor', 'terrible', 'horrible', 'awful']

# Función para analizar el sentimiento con ajuste para palabras clave en review_title
def analyze_title_sentiment(text):
    sentiment = sia.polarity_scores(text)
    compound_score = sentiment['compound']

    # Ajuste basado en palabras clave
    text_lower = text.lower()
    if any(word in text_lower for word in positive_keywords):
        compound_score += 0.1  # Pequeño impulso positivo
    if any(word in text_lower for word in negative_keywords):
        compound_score -= 0.1  # Pequeño impulso negativo

    # Asignación de etiqueta basada en el puntaje ajustado
    if compound_score >= 0.3:
        sentiment_label = 'Positivo'
    elif compound_score <= -0.3:
        sentiment_label = 'Negativo'
    else:
        sentiment_label = 'Neutral'

    return compound_score, sentiment_label

# Aplicar el análisis de sentimientos solo a los títulos de las reseñas
df[['title_sentiment', 'title_sentiment_label']] = df['review_title'].apply(lambda x: pd.Series(analyze_title_sentiment(x)))

# Mostrar las primeras filas con el análisis de sentimientos del título
df[['review_title', 'title_sentiment', 'title_sentiment_label']].head()

# Función para analizar el sentimiento con ajuste para palabras clave en review_title
def analyze_title_sentiment(text):
    sentiment = sia.polarity_scores(text)
    compound_score = sentiment['compound']

    # Ajuste basado en palabras clave negativas
    text_lower = text.lower()
    if any(word in text_lower for word in ['good', 'great', 'excellent', 'amazing', 'fantastic']):
        compound_score += 0.2  # Incrementar impacto positivo
    if any(word in text_lower for word in ['bad', 'poor', 'terrible', 'horrible', 'awful', 'worst', 'disappointing', 'not good', 'not buy']):
        compound_score -= 0.4  # Incrementar impacto negativo

    # Asignación de etiqueta basada en el puntaje ajustado
    if compound_score >= 0.3:
        sentiment_label = 'Positivo'
    elif compound_score <= -0.3:
        sentiment_label = 'Negativo'
    else:
        sentiment_label = 'Neutral'

    return compound_score, sentiment_label

# Aplicar el análisis de sentimientos a los títulos de las reseñas
df[['title_sentiment', 'title_sentiment_label']] = df['review_title'].apply(lambda x: pd.Series(analyze_title_sentiment(x)))

# Agrupar la tabla por product_id
grouped_df = df.groupby('product_id').agg(
    review_content=('review_content', 'first'),  # Mantener review_content igual
    user_count=('user_name', 'count'),  # Conteo de usuarios
    user_names=('user_name', lambda x: ', '.join(x)),  # Agrupar user_name por product_id, separados por comas
    review_titles=('review_title', lambda x: ', '.join(x)),  # Agrupar review_title por product_id, separados por comas
    avg_sentiment=('title_sentiment', 'mean'),  # Promedio de los puntajes de sentimiento
).reset_index()

# Asignar una nueva etiqueta de sentimiento basada en el promedio
grouped_df['title_sentiment_label'] = grouped_df['avg_sentiment'].apply(lambda x: 'Positivo' if x >= 0.3 else 'Negativo' if x <= -0.3 else 'Neutral')

# Agregar las columnas que no se agruparon (mantenerlas igual que en el primer registro de cada grupo)
grouped_df = pd.merge(grouped_df, df[['product_id', 'img_link', 'product_link', 'rating', 'rating_count']].drop_duplicates(), on='product_id', how='left')

# Ordenar las columnas según lo especificado
final_df = grouped_df[['product_id', 'user_names', 'user_count', 'review_titles', 'review_content', 'img_link', 'product_link', 'rating', 'rating_count', 'avg_sentiment', 'title_sentiment_label']]

# Mostrar las primeras filas del DataFrame final para ver el resultado
final_df.head()
display(final_df)

# Definir la paleta de colores de Amazon
amazon_colors = ['#000000', '#FF9900', '#146EB4', '#FFFFFF']

# Contar la cantidad de cada sentimiento
sentiment_counts = final_df['title_sentiment_label'].value_counts()

# Crear el gráfico circular
fig = px.pie(
    values=sentiment_counts.values,
    names=sentiment_counts.index,
    title='Distribución de Sentimientos',
    color_discrete_sequence=amazon_colors,  # Usar la paleta de colores de Amazon
    hole=0.4,  # Espacio en el centro del gráfico
)

# Ajustar el tamaño del gráfico
fig.update_layout(
    width=700,  # Ajustar el ancho
    height=500,  # Ajustar la altura
    annotations=[dict(text='Sentimientos', x=0.5, y=0.5, font_size=18, showarrow=False)])


# Mostrar el gráfico
fig.show()

# Guardar la tabla agrupada y extendida en un nuevo archivo CSV
output_file_path = 'amazon_reviews_grouped_final_with_sentiment.csv'
final_df.to_csv(output_file_path, index=False)

# Descargar el archivo generado
from google.colab import files
files.download(output_file_path)

# Descargar opinion_lexicon (si no lo tienes)
!pip install nltk # install nltk if it's not already installed
import nltk # import the nltk library
nltk.download('opinion_lexicon')

# Lista de palabras positivas y negativas de la librería nltk
from nltk.corpus import opinion_lexicon # import the opinion_lexicon
positive_words = set(opinion_lexicon.positive())
negative_words = set(opinion_lexicon.negative())

# Análisis de la longitud de las reseñas
df['review_length'] = df['review_title'].apply(len)

# Visualización de la distribución de la longitud de las reseñas
import matplotlib.pyplot as plt # import matplotlib
import seaborn as sns # import seaborn

plt.figure(figsize=(10, 6))

# Histograma con la paleta de Amazon
sns.histplot(df['review_length'], bins=50, kde=True, color='#000000')  # Color principal

# Personalización del gráfico con los colores de la paleta de Amazon
plt.title('Distribution of Review Length', color='#000000')  # Título en color negro
plt.xlabel('Review Length', color='#FF9900')  # Etiqueta del eje x en color #FF9900
plt.ylabel('Frequency', color='#FFFFFF')  # Etiqueta del eje y en color blanco
plt.grid(True, color='#000000')  # Líneas de la cuadrícula en color negro

# Mostrar gráfico
plt.show()
print()

# Unir todos los títulos de reseñas procesados en un solo string
all_processed_titles = ' '.join(df['review_title'])

# Contar la frecuencia de cada palabra
from collections import Counter # import the Counter object from the collections module
word_counts = Counter(all_processed_titles.split())

# Filtrar solo las palabras que son referidas a sentimientos
feeling_words = {word: count for word, count in word_counts.items() if word in positive_words or word in negative_words}

# Obtener las 20 palabras más comunes referidas a sentimientos
top_20_feeling_words = Counter(feeling_words).most_common(20)

# Crear un gráfico de barras de las palabras más comunes relacionadas a sentimientos
plt.figure(figsize=(12, 6))

# Aplicar los colores de Amazon a las barras, alternando entre ellos
amazon_colors = ['#000000', '#FF9900', '#146EB4', '#FFFFFF']
colors = [amazon_colors[i % len(amazon_colors)] for i in range(len(top_20_feeling_words))]

plt.bar([word for word, count in top_20_feeling_words],
        [count for word, count in top_20_feeling_words],
        color=colors)  # Asignar colores de la paleta de Amazon

plt.xticks(rotation=90, color='#000000')  # Etiquetas de las palabras en negro
plt.title('Top 20 Most Frequent Feeling Words in Review Titles', color='#000000')  # Título en color negro
plt.xlabel('Feeling Word', color='#000000')  # Etiqueta en color negro
plt.ylabel('Frequency', color='#000000')  # Etiqueta en color negro
plt.show()

from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
import random

# Obtener las palabras y sus frecuencias del top 20
top_20_words = dict(top_20_feeling_words)

# Definir la paleta de colores de Amazon
amazon_colors = ['#000000', '#FF9900', '#146EB4']

# Función para generar colores aleatorios de la paleta de Amazon
def amazon_color_func(word, font_size, position, orientation, random_state=None, **kwargs):
    return random.choice(amazon_colors)

# Crear la nube de palabras
wordcloud = WordCloud(
    width=800,
    height=400,
    background_color='white',
    color_func=amazon_color_func,  # Usar la paleta de colores de Amazon
    stopwords=STOPWORDS,
    min_font_size=10
).generate_from_frequencies(top_20_words)

# Mostrar la nube de palabras
plt.figure(figsize=(8, 8), facecolor=None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad=0)
plt.show()

# Crear un DataFrame con las palabras más comunes relacionadas a sentimientos
top_feeling_words_df = pd.DataFrame(top_20_feeling_words, columns=['Word', 'Frequency'])
display(top_feeling_words_df)

# Exportar el DataFrame a un archivo CSV
top_feeling_words_df.to_csv('top_feeling_words.csv', index=False)

# Descargar el archivo generado
files.download('top_feeling_words.csv')